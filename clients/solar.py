#!/usr/bin/env python2

# Adapted from https://github.com/Woutrrr/Omnik-Data-Logger

import os;
import socket;
import sys;
import time;
import struct  # Converting bytes to numbers
from datetime import datetime

serial_no=123456;
ip = "XX.XX.XX.XX"
port = 8899;
daemon = 1;
verbose = 0;

newSolarSerial=''
oldSolarSerial=''
oldSolarTotalDay=0;
newSolarTotalDay=0;
newSolarTotal=0;
oldSolarTotal=0;
oldSolarCurrent=0;
newSolarCurrent=0;
newSolarNorthCurrent=0;
oldSolarNorthCurrent=0;
newSolarSouthCurrent=0;
oldSolarSouthCurrent=0;

if daemon == 1:
	try:
		pid = os.fork();
		if pid > 0:
			exit(0)
	except OSError, e:
		exit(1)

	os.chdir("/")
	os.setsid()
	os.umask(0)

	try:
		pid = os.fork()
		if pid > 0:
			exit(0)
	except OSError, e:
		exit(1)

class InverterMsg(object):
    """Decode the response message from an omniksol inverter."""
    raw_msg = ""

    def __init__(self, msg, offset=0):
        self.raw_msg = msg
        self.offset = offset

    def __get_string(self, begin, end):
        """Extract string from message.

        Args:
            begin (int): starting byte index of string
            end (int): end byte index of string

        Returns:
            str: String in the message from start to end
        """
        return self.raw_msg[begin:end]

    def __get_short(self, begin, divider=10):
        """Extract short from message.

        The shorts in the message could actually be a decimal number. This is
        done by storing the number multiplied in the message. So by dividing
        the short the original decimal number can be retrieved.

        Args:
            begin (int): index of short in message
            divider (int): divider to change short to float. (Default: 10)

        Returns:
            int or float: Value stored at location `begin`
        """
        num = struct.unpack('!H', self.raw_msg[begin:begin + 2])[0]
        if num == 65535:
            return -1
        else:
            return float(num) / divider

    def __get_long(self, begin, divider=10):
        """Extract long from message.

        The longs in the message could actually be a decimal number. By
        dividing the long, the original decimal number can be extracted.

        Args:
            begin (int): index of long in message
            divider (int): divider to change long to float. (Default : 10)

        Returns:
            int or float: Value stored at location `begin`
        """
        return float(
            struct.unpack('!I', self.raw_msg[begin:begin + 4])[0]) / divider

    @property
    def id(self):
        """ID of the inverter."""
        return self.__get_string(15, 31)

    @property
    def temperature(self):
        """Temperature recorded by the inverter."""
        return self.__get_short(31)

    @property
    def power(self):
        """Power output"""
        return self.__get_short(59)

    @property
    def e_total(self):
        """Total energy generated by inverter in kWh"""
        return self.__get_long(71)

    def v_pv(self, i=1):
        """Voltage of PV input channel.

        Available channels are 1, 2 or 3; if not in this range the function will
        default to channel 1.

        Args:
            i (int): input channel (valid values: 1, 2, 3)

        Returns:
            float: PV voltage of channel i
        """
        if i not in range(1, 4):
            i = 1
        num = 33 + (i - 1) * 2
        return self.__get_short(num)

    def i_pv(self, i=1):
        """Current of PV input channel.

        Available channels are 1, 2 or 3; if not in this range the function will
        default to channel 1.

        Args:
            i (int): input channel (valid values: 1, 2, 3)

        Returns:
            float: PV current of channel i
        """
        if i not in range(1, 4):
            i = 1
        num = 39 + (i - 1) * 2
        return self.__get_short(num)

    def i_ac(self, i=1):
        """Current of the Inverter output channel

        Available channels are 1, 2 or 3; if not in this range the function will
        default to channel 1.

        Args:
            i (int): output channel (valid values: 1, 2, 3)

        Returns:
            float: AC current of channel i

        """
        if i not in range(1, 4):
            i = 1
        num = 45 + (i - 1) * 2
        return self.__get_short(num)

    def v_ac(self, i=1):
        """Voltage of the Inverter output channel

        Available channels are 1, 2 or 3; if not in this range the function will
        default to channel 1.

        Args:
            i (int): output channel (valid values: 1, 2, 3)

        Returns:
            float: AC voltage of channel i
        """
        if i not in range(1, 4):
            i = 1
        num = 51 + (i - 1) * 2
        return self.__get_short(num)

    def f_ac(self, i=1):
        """Frequency of the output channel

        Available channels are 1, 2 or 3; if not in this range the function will
        default to channel 1.

        Args:
            i (int): output channel (valid values: 1, 2, 3)

        Returns:
            float: AC frequency of channel i
        """
        if i not in range(1, 4):
            i = 1
        num = 57 + (i - 1) * 4
        return self.__get_short(num, 100)

    def p_ac(self, i=1):
        """Power output of the output channel

        Available channels are 1, 2 or 3; if no tin this range the function will
        default to channel 1.

        Args:
            i (int): output channel (valid values: 1, 2, 3)

        Returns:
            float: Power output of channel i
        """
        if i not in range(1, 4):
            i = 1
        num = 59 + (i - 1) * 4
        return int(self.__get_short(num, 1))  # Don't divide

    @property
    def e_today(self):
        """Energy generated by inverter today in kWh"""
        return self.__get_short(69, 100)  # Divide by 100

    @property
    def h_total(self):
        """Hours the inverter generated electricity"""
        return int(self.__get_long(75, 1))  # Don't divide

def generate_string(serial_no):
	response = '\x68\x02\x40\x30'

	double_hex = hex(serial_no)[2:] * 2
	hex_list = [double_hex[i:i + 2].decode('hex') for i in reversed(range(0, len(double_hex), 2))]

	cs_count = 115 + sum([ord(c) for c in hex_list])
	checksum = hex(cs_count)[-2:].decode('hex')
	response += ''.join(hex_list) + '\x01\x00' + checksum + '\x16'

	return response

for res in socket.getaddrinfo(ip, port, socket.AF_INET, socket.SOCK_STREAM):
	family, socktype, proto, canonname, sockadress = res

	while(1):
		try:
			#print('connecting to {0} port {1}'.format(ip, port))
			sock = socket.socket(family, socktype, proto)
			sock.settimeout(5)
			sock.connect(sockadress)
		except socket.error as msg:
			if(verbose == 1):
				print(msg)
			time.sleep(60);
			continue;
			#sys.exit(1)

		hash = generate_string(serial_no);

		sock.sendall(hash);
		while(1):
			try:
				data = sock.recv(1024);
			except socket.timeout as msg:
				sock.close();
				if(verbose == 1):
					print("Socket timeout");
				break;

			if(verbose == 1):
				print(len(data));

			if(len(data) == 0):
				sock.close();
				if(verbose == 1):
					print("Socket message 0");
				break;

			if(len(data) == 103):
				msg = InverterMsg(data)
				newSolarSerial = msg.id;
				newSolarCurrent = msg.p_ac(1);
				newSolarNorthCurrent = msg.v_pv(1)*msg.i_pv(1);
				newSolarSouthCurrent = msg.v_pv(2)*msg.i_pv(2);
				newSolarTotal = msg.e_total;
				newSolarTotalDay = msg.e_today;

				dt = datetime.now();

				try:
					file = open("/cache/queries.sql", "a")

					if(oldSolarSerial != newSolarSerial):
						oldSolarSerial = newSolarSerial;

					if(abs(newSolarCurrent-oldSolarCurrent) > 10):
						oldSolarCurrent = newSolarCurrent
						file.write("INSERT INTO consumption (dev_id, rate_id, `usage`, `datetime`, direction) VALUES ((SELECT dev_id FROM devices WHERE name = '%s'), (SELECT rate_id FROM rate_types WHERE name = 'both'), %.2f, to_timestamp('%s', 'YYYY-MM-DD HH24:MI:SS')::timestamp without time zone, 1);\n" % (newSolarSerial, newSolarCurrent, dt))

					if(abs(newSolarSouthCurrent-oldSolarSouthCurrent) > 10):
						oldSolarSouthCurrent = newSolarSouthCurrent;
						file.write("INSERT INTO consumption (dev_id, rate_id, `usage`, `datetime`, direction) VALUES ((SELECT dev_id FROM devices WHERE name = '%s'), (SELECT rate_id FROM rate_types WHERE name = 'south'), %.2f, to_timestamp('%s', 'YYYY-MM-DD HH24:MI:SS')::timestamp without time zone, 1);\n" % (newSolarSerial, newSolarSouthCurrent, dt))

					if(abs(newSolarNorthCurrent-oldSolarNorthCurrent) > 10):
						oldSolarNorthCurrent = newSolarNorthCurrent;
						file.write("INSERT INTO consumption (dev_id, rate_id, `usage`, `datetime`, direction) VALUES ((SELECT dev_id FROM devices WHERE name = '%s'), (SELECT rate_id FROM rate_types WHERE name = 'north'), %.2f, to_timestamp('%s', 'YYYY-MM-DD HH24:MI:SS')::timestamp without time zone, 1);\n" % (newSolarSerial, newSolarNorthCurrent, dt))

					if(newSolarTotal != oldSolarTotal):
						oldSolarTotal = newSolarTotal;
						file.write("INSERT INTO consumption (dev_id, rate_id, `usage`, `datetime`, direction) VALUES ((SELECT dev_id FROM devices WHERE name = '%s'), (SELECT rate_id FROM rate_types WHERE name = 'total'), %.2f, to_timestamp('%s', 'YYYY-MM-DD HH24:MI:SS')::timestamp without time zone, 1);\n" % (newSolarSerial, newSolarTotal, dt))

					if(newSolarTotalDay != oldSolarTotalDay):
						oldSolarTotalDay = newSolarTotalDay;
						file.write("INSERT INTO consumption (dev_id, rate_id, `usage`, `datetime`, direction) VALUES ((SELECT dev_id FROM devices WHERE name = '%s'), (SELECT rate_id FROM rate_types WHERE name = 'day'), %.2f, to_timestamp('%s', 'YYYY-MM-DD HH24:MI:SS')::timestamp without time zone, 1);\n" % (newSolarSerial, newSolarTotalDay, dt))

					file.close();	

				except Exception as e:
					if verbose == 1:
						print(e);
					pass

				finally:
					pass;

				if(verbose == 1):
					print "Time: {0}".format(dt)
					print "ID: {0}".format(msg.id)

					print "E Today: {0:>5}   Total: {1:<5}".format(msg.e_today, msg.e_total)
					print "H Total: {0:>5}   Temp:  {1:<5}".format(msg.h_total, msg.temperature)

					print "PV1   V: {0:>5}   I: {1:>4}".format(msg.v_pv(1), msg.i_pv(1))
					print "PV2   V: {0:>5}   I: {1:>4}".format(msg.v_pv(2), msg.i_pv(2))
					print "PV3   V: {0:>5}   I: {1:>4}".format(msg.v_pv(3), msg.i_pv(3))

					print "L1    P: {0:>5}   V: {1:>5}   I: {2:>4}   F: {3:>5}".format(msg.p_ac(1), msg.v_ac(1), msg.i_ac(1), msg.f_ac(1))
					print "L2    P: {0:>5}   V: {1:>5}   I: {2:>4}   F: {3:>5}".format(msg.p_ac(2), msg.v_ac(2), msg.i_ac(2), msg.f_ac(2))
					print "L3    P: {0:>5}   V: {1:>5}   I: {2:>4}   F: {3:>5}".format(msg.p_ac(3), msg.v_ac(3), msg.i_ac(3), msg.f_ac(3))

		time.sleep(5);

		sock.close();
